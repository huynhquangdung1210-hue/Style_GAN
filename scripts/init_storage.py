#!/usr/bin/env python3
"""
Storage Initialization Script

Initializes storage backends (MinIO bucket creation, S3 setup) for the style transfer service.
"""

import asyncio
import sys
from pathlib import Path\n\n# Add src to path so we can import our modules\nsys.path.append(str(Path(__file__).parent.parent / \"src\"))\n\nfrom utils.storage import get_storage_client, StorageError\nfrom utils.config import get_settings\nimport structlog\n\nlogger = structlog.get_logger()\n\n\nasync def init_minio_bucket():\n    \"\"\"Initialize MinIO bucket if it doesn't exist.\"\"\"\n    settings = get_settings().storage\n    \n    if settings.storage_type != \"minio\":\n        logger.info(\"Skipping MinIO initialization - not using MinIO storage\")\n        return\n    \n    try:\n        client = get_storage_client()\n        \n        # MinIO client auto-creates bucket in the storage client\n        # Let's just test the connection by checking if we can access the client\n        minio_client = client.minio_client\n        \n        # Check if bucket exists\n        bucket_exists = minio_client.bucket_exists(settings.minio_bucket)\n        \n        if bucket_exists:\n            logger.info(\"MinIO bucket already exists\", bucket=settings.minio_bucket)\n        else:\n            logger.info(\"MinIO bucket created\", bucket=settings.minio_bucket)\n            \n        # Test upload/download\n        test_content = b\"test-content\"\n        test_key = \"test/init.txt\"\n        \n        await client.upload_bytes(test_content, test_key, \"text/plain\")\n        logger.info(\"Test upload successful\")\n        \n        downloaded = await client.download_file(test_key)\n        if downloaded == test_content:\n            logger.info(\"Test download successful\")\n        \n        # Clean up test file\n        await client.delete_file(test_key)\n        logger.info(\"MinIO initialization completed successfully\")\n        \n    except Exception as e:\n        logger.error(\"MinIO initialization failed\", error=str(e))\n        raise StorageError(f\"Failed to initialize MinIO: {str(e)}\")\n\n\nasync def init_local_storage():\n    \"\"\"Initialize local storage directory.\"\"\"\n    settings = get_settings().storage\n    \n    if settings.storage_type != \"local\":\n        return\n    \n    storage_path = Path(settings.local_storage_path)\n    storage_path.mkdir(parents=True, exist_ok=True)\n    \n    # Create subdirectories\n    subdirs = [\"uploads\", \"results\", \"temp\", \"cache\"]\n    for subdir in subdirs:\n        (storage_path / subdir).mkdir(exist_ok=True)\n    \n    logger.info(\"Local storage initialized\", path=str(storage_path))\n\n\nasync def test_storage_backend():\n    \"\"\"Test the configured storage backend.\"\"\"\n    settings = get_settings().storage\n    logger.info(\"Testing storage backend\", backend=settings.storage_type)\n    \n    try:\n        client = get_storage_client()\n        \n        # Test file operations\n        test_content = b\"Hello, Style Transfer!\"\n        test_key = f\"test/{settings.storage_type}_test.txt\"\n        \n        # Upload test\n        url = await client.upload_bytes(test_content, test_key, \"text/plain\")\n        logger.info(\"Upload test passed\", url=url)\n        \n        # Download test\n        downloaded = await client.download_file(test_key)\n        if downloaded == test_content:\n            logger.info(\"Download test passed\")\n        else:\n            raise StorageError(\"Download content mismatch\")\n        \n        # URL test\n        file_url = client.get_file_url(test_key)\n        logger.info(\"URL generation test passed\", url=file_url)\n        \n        # Cleanup\n        deleted = await client.delete_file(test_key)\n        if deleted:\n            logger.info(\"Delete test passed\")\n        \n        logger.info(\"All storage tests passed successfully\")\n        \n    except Exception as e:\n        logger.error(\"Storage test failed\", error=str(e))\n        raise\n\n\nasync def main():\n    \"\"\"Main initialization function.\"\"\"\n    logger.info(\"Starting storage initialization...\")\n    \n    settings = get_settings()\n    logger.info(\"Storage configuration\", \n               backend=settings.storage.storage_type,\n               minio_endpoint=settings.storage.minio_endpoint if settings.storage.storage_type == \"minio\" else \"N/A\",\n               s3_bucket=settings.storage.s3_bucket if settings.storage.storage_type == \"s3\" else \"N/A\",\n               local_path=settings.storage.local_storage_path if settings.storage.storage_type == \"local\" else \"N/A\")\n    \n    try:\n        # Initialize based on storage type\n        if settings.storage.storage_type == \"minio\":\n            await init_minio_bucket()\n        elif settings.storage.storage_type == \"local\":\n            await init_local_storage()\n        elif settings.storage.storage_type == \"s3\":\n            logger.info(\"S3 storage - assuming bucket exists\")\n        \n        # Test the storage backend\n        await test_storage_backend()\n        \n        logger.info(\"Storage initialization completed successfully!\")\n        \n    except Exception as e:\n        logger.error(\"Storage initialization failed\", error=str(e))\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    # Configure logging\n    structlog.configure(\n        processors=[\n            structlog.stdlib.filter_by_level,\n            structlog.stdlib.add_logger_name,\n            structlog.stdlib.add_log_level,\n            structlog.stdlib.PositionalArgumentsFormatter(),\n            structlog.processors.TimeStamper(fmt=\"iso\"),\n            structlog.processors.StackInfoRenderer(),\n            structlog.processors.format_exc_info,\n            structlog.processors.UnicodeDecoder(),\n            structlog.processors.JSONRenderer()\n        ],\n        context_class=dict,\n        logger_factory=structlog.stdlib.LoggerFactory(),\n        wrapper_class=structlog.stdlib.BoundLogger,\n        cache_logger_on_first_use=True,\n    )\n    \n    asyncio.run(main())\n